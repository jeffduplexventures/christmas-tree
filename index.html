<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Duplex Ventures Christmas</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; align-items: center; padding-top: 5vh;
        }
        
        h1 {
            color: #fff; font-family: serif; 
            font-size: 24px; line-height: 1.4; letter-spacing: 2px; text-align: center;
            margin: 0; text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow { from { text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); } to { text-shadow: 0 0 25px rgba(255, 215, 0, 1); } }

        #status-bar {
            margin-top: 15px; color: #ffd700; font-size: 14px;
            background: rgba(0, 0, 0, 0.6); padding: 5px 15px; border-radius: 20px;
            border: 1px solid rgba(255, 215, 0, 0.4); transition: opacity 0.3s;
        }

        .instruction {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.7); font-size: 13px; letter-spacing: 1px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding-bottom: 25px; line-height: 1.6;
        }
        .instruction b { color: #ffd700; }

        #photo-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            width: 85vw; max-width: 320px; height: auto; aspect-ratio: 3/4;
            background: rgba(20, 20, 20, 0.9); 
            border: 2px solid #D4AF37; border-radius: 15px;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; transition: all 0.3s ease-out;
            z-index: 100; pointer-events: none;
        }
        #photo-overlay.active { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        #photo-overlay img { width: 100%; height: 100%; object-fit: contain; border-radius: 12px; }

        /* éšè—è§†é¢‘ä½†ä¿ç•™å ä½ */
        .input_video { position: absolute; opacity: 0; width: 1px; height: 1px; pointer-events: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <h1>Duplex Ventures<br>Wish You A<br>Merry Christmas</h1>
        <div id="status-bar">Initialize System...</div>
        <div id="photo-overlay"><img id="card-image" src="" crossorigin="anonymous"></div>
        <div class="instruction">
            ğŸ– <b>Open Hand</b>: Show Photos<br>
            ğŸ‘‹ <b>Tilt</b>: Select &nbsp;|&nbsp; ğŸ‘Œ <b>Pinch</b>: Open
        </div>
    </div>

    <video class="input_video" playsinline muted autoplay></video>
    <div id="canvas-container"></div>

<script>
    // ==========================================
    // 1. ä¼˜å…ˆå¯åŠ¨ 3D åœºæ™¯ (ä¿è¯çœ‹è§æ ‘)
    // ==========================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020202); 
    scene.fog = new THREE.FogExp2(0x020202, 0.001);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(0, 100, 550); 
    camera.lookAt(0, 120, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // --- åˆ›å»ºç²’å­æ ‘ ---
    function createGlowTexture() {
        const size = 64; const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
        const ctx = cvs.getContext('2d'); const c = size / 2;
        const g = ctx.createRadialGradient(c, c, 0, c, c, c);
        g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(c, c, c, 0, 2 * Math.PI); ctx.fill(); 
        return new THREE.Texture(cvs);
    }
    const particleTexture = createGlowTexture();
    particleTexture.needsUpdate = true;
    
    const treeGroup = new THREE.Group(); 
    treeGroup.position.y = 120; 
    scene.add(treeGroup);

    // ç²’å­é€»è¾‘
    const isMobile = window.innerWidth < 768; 
    const particleCount = isMobile ? 5000 : 12000; 
    const treeHeight = 280; 
    const baseRadius = 110;
    
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount*3); 
    const initialPositions = new Float32Array(particleCount*3);
    const scatterDirs = new Float32Array(particleCount*3); 
    const colors = new Float32Array(particleCount*3);
    const blinkOffsets = new Float32Array(particleCount); 
    const blinkSpeeds = new Float32Array(particleCount);
    
    const colGold = new THREE.Color(0xffcc00); 
    const colWhite = new THREE.Color(0xffffee); 
    const colRed = new THREE.Color(0xff0033);

    for (let i = 0; i < particleCount; i++) {
        const hRatio = Math.pow(Math.random(), 0.8); 
        const y = (hRatio - 0.5) * treeHeight;
        let r = baseRadius * (1 - hRatio) + (Math.random()-0.5)*20; r = Math.max(0,r);
        const theta = Math.random()*Math.PI*2; 
        const x=r*Math.cos(theta); const z=r*Math.sin(theta);
        
        initialPositions[i*3]=x; initialPositions[i*3+1]=y; initialPositions[i*3+2]=z;
        positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
        
        // çˆ†ç‚¸æ–¹å‘
        let dirX = x; let dirY = y-50; let dirZ = z; 
        const len = Math.sqrt(dirX*dirX+dirY*dirY+dirZ*dirZ);
        const speed = 100 + Math.random() * 250; 
        scatterDirs[i*3]=dirX/len*speed; scatterDirs[i*3+1]=dirY/len*speed; scatterDirs[i*3+2]=dirZ/len*speed;

        let c = Math.random()>0.85 ? colRed : (Math.random()>0.5 ? colWhite : colGold);
        colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
        blinkOffsets[i]=Math.random()*Math.PI*2; blinkSpeeds[i]=0.5+Math.random()*2.0;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const pMaterial = new THREE.PointsMaterial({ 
        size: isMobile?4.5:3.5, vertexColors:true, map:particleTexture, 
        blending:THREE.AdditiveBlending, depthWrite:false, transparent:true 
    });
    const particles = new THREE.Points(geometry, pMaterial); 
    treeGroup.add(particles);

    // æ˜Ÿæ˜Ÿ
    const topStar = new THREE.Mesh(new THREE.OctahedronGeometry(10,0), new THREE.MeshBasicMaterial({color:0xffffee, wireframe:true}));
    topStar.position.set(0, treeHeight/2+8, 0); 
    treeGroup.add(topStar);
    const starGlow = new THREE.Sprite(new THREE.SpriteMaterial({map:particleTexture, color:0xffd700, blending:THREE.AdditiveBlending}));
    starGlow.scale.set(70,70,1); 
    topStar.add(starGlow);


    // ==========================================
    // 2. åå°åŠ è½½å›¾ç‰‡ (ä¸é˜»å¡æ ‘çš„æ˜¾ç¤º)
    // ==========================================
    const hangingGroup = new THREE.Group();
    scene.add(hangingGroup);
    hangingGroup.visible = false;
    
    // ç”Ÿæˆè´ºå¡
    function generateCard() {
        const cvs = document.createElement('canvas'); cvs.width = 600; cvs.height = 800;
        const ctx = cvs.getContext('2d');
        const grad = ctx.createLinearGradient(0,0,0,800); grad.addColorStop(0, '#8B0000'); grad.addColorStop(1, '#300000');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, 600, 800);
        ctx.strokeStyle = '#D4AF37'; ctx.lineWidth = 15; ctx.strokeRect(20, 20, 560, 760); ctx.lineWidth = 2; ctx.strokeRect(35, 35, 530, 730);
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 10;
        ctx.fillStyle = '#D4AF37'; ctx.font = 'bold 55px serif'; ctx.fillText('Duplex Ventures', 300, 260);
        ctx.fillStyle = '#FFF'; ctx.font = 'italic 40px serif'; ctx.fillText('Wish You A', 300, 340);
        ctx.fillStyle = '#D4AF37'; ctx.font = 'bold 65px serif'; ctx.fillText('Merry Christmas', 300, 440);
        ctx.fillStyle = '#FFF'; ctx.font = '40px serif'; ctx.fillText('â˜…', 300, 160); ctx.fillText('â˜…', 300, 560);
        return cvs;
    }

    const photoUrls = [
        null, 
        'https://images.unsplash.com/photo-1543589077-47d81606c1bf?w=500&q=80',
        'https://images.unsplash.com/photo-1512909006721-3d6018887383?w=500&q=80',
        'https://images.unsplash.com/photo-1545048702-79362596cdc9?w=500&q=80',
        'https://images.unsplash.com/photo-1576919228236-a097c32a5cd4?w=500&q=80'
    ];
    
    const photoMeshes = [];
    const photoTextures = [];
    const photoGallerySrcs = [];

    // åˆå§‹åŒ–å ä½ç¬¦
    const cardCanvas = generateCard();
    photoGallerySrcs[0] = cardCanvas.toDataURL();
    photoTextures[0] = new THREE.CanvasTexture(cardCanvas);

    // é¢„å…ˆåˆ›å»º3Då¯¹è±¡(ç”¨ç™½è‰²æ–¹å—å ä½ï¼Œç­‰å›¾ç‰‡åŠ è½½å¥½äº†å†è´´ä¸Šå»)
    const planeGeo = new THREE.PlaneGeometry(60, 80);
    const frameGeo = new THREE.PlaneGeometry(66, 86);
    const frameMat = new THREE.MeshBasicMaterial({ color: 0xD4AF37 });
    
    const radius = 250; 
    const angleStep = 30 * (Math.PI / 180); 
    const startAngle = -2 * angleStep; 

    for(let i=0; i<5; i++) {
        const group = new THREE.Group();
        group.add(new THREE.Mesh(frameGeo, frameMat));
        
        const mat = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide }); // é»˜è®¤æ·±è‰²
        // å¦‚æœæ˜¯ç¬¬ä¸€å¼ ï¼Œç›´æ¥è´´å›¾
        if(i===0) mat.map = photoTextures[0]; mat.color.set(0xffffff);

        const mesh = new THREE.Mesh(planeGeo, mat);
        mesh.position.z = 1; group.add(mesh);
        
        const angle = startAngle + (i*angleStep);
        group.position.set(radius*Math.sin(angle), 160, radius*Math.cos(angle)-radius+50);
        group.lookAt(camera.position);
        
        hangingGroup.add(group);
        photoMeshes.push({ group, material: mat, basePos: { ...group.position }, textureLoaded: i===0 });
        
        // å¼‚æ­¥åŠ è½½å›¾ç‰‡
        if(i > 0) {
            photoGallerySrcs[i] = photoUrls[i];
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');
            loader.load(
                photoUrls[i], 
                (tex) => { 
                    mat.map = tex; 
                    mat.color.set(0xffffff); 
                    mat.needsUpdate = true;
                    photoTextures[i] = tex;
                },
                undefined,
                (err) => { console.log('Image load failed, keeping placeholder'); }
            );
        }
    }


    // ==========================================
    // 3. é€»è¾‘ä¸åŠ¨ç”»
    // ==========================================
    let state = { 
        isHandDetected: false, handRotation: 0, isPinch: false, 
        scatterFactor: 0, targetFactor: 0, selectedIndex: 2, smoothIndex: 2 
    };
    const cardImageElement = document.getElementById('card-image');
    const photoOverlay = document.getElementById('photo-overlay');
    const statusBar = document.getElementById('status-bar');

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.003;

        // åŠ¨ç”»å¹³æ»‘
        state.scatterFactor += (state.targetFactor - state.scatterFactor) * 0.05;
        const exploded = state.scatterFactor > 0.5;
        const explosionProgress = state.scatterFactor;
        const explosionScale = 1 - Math.pow(1 - explosionProgress, 3);

        // ç²’å­æ›´æ–°
        const posAttr = geometry.attributes.position;
        for(let i=0; i<particleCount; i++) {
            const ix=i*3; const iy=i*3+1; const iz=i*3+2;
            if (explosionProgress < 0.05) {
                posAttr.array[ix] = initialPositions[ix];
                posAttr.array[iy] = initialPositions[iy];
                posAttr.array[iz] = initialPositions[iz];
            } else {
                posAttr.array[ix] = initialPositions[ix] + scatterDirs[ix] * explosionScale;
                posAttr.array[iz] = initialPositions[iz] + scatterDirs[iz] * explosionScale;
                posAttr.array[iy] = initialPositions[iy] + scatterDirs[iy] * explosionScale - (200 * explosionScale * explosionScale);
            }
        }
        posAttr.needsUpdate = true;
        
        // æ˜Ÿæ˜Ÿæ›´æ–°
        topStar.position.y = (treeHeight/2+8) - (200 * explosionScale * explosionScale);
        topStar.material.opacity = 1 - explosionProgress; 
        starGlow.material.opacity = 0.8 * (1 - explosionProgress);

        // æ‚¬æµ®ç…§ç‰‡é€»è¾‘
        if (explosionProgress > 0.1) {
            hangingGroup.visible = true;
            
            // æ‰‹åŠ¿é€‰æ‹©è®¡ç®—
            if (state.isHandDetected) {
                let rot = Math.max(-1.2, Math.min(1.2, state.handRotation));
                let mapped = ((rot + 1.2) / 2.4) * 5;
                state.smoothIndex += (mapped - state.smoothIndex) * 0.1; 
                state.selectedIndex = Math.floor(Math.max(0, Math.min(4.9, state.smoothIndex)));
                statusBar.innerText = state.isPinch ? "OPENING..." : `PHOTO ${state.selectedIndex + 1}`;
                statusBar.style.opacity = 1;
            } else {
                statusBar.style.opacity = 0.5; statusBar.innerText = "Show Hand";
            }

            // ç…§ç‰‡åŠ¨æ€æ•ˆæœ
            photoMeshes.forEach((meshObj, index) => {
                const group = meshObj.group;
                let targetScale = explosionProgress; 
                if (index === state.selectedIndex) {
                    targetScale *= 1.4; 
                    group.position.z += (50 - group.position.z) * 0.1; // å‡¸èµ·
                    if(meshObj.material.color.r < 1) meshObj.material.color.set(0xffffff); // äº®
                } else {
                    targetScale *= 0.8; 
                    group.position.z += (meshObj.basePos.z - group.position.z) * 0.1; // å¤ä½
                    meshObj.material.color.set(0x666666); // æš—
                }
                group.scale.setScalar(targetScale);
                group.position.y = meshObj.basePos.y + Math.sin(time + index) * 5;
            });
        } else {
            hangingGroup.visible = false;
            if(!state.isHandDetected) statusBar.innerText = "Waiting for Camera...";
        }

        // å¼¹çª—é€»è¾‘
        if (state.isPinch && exploded) {
            // å®‰å…¨è®¾ç½® src
            const targetSrc = photoGallerySrcs[state.selectedIndex];
            if (targetSrc && cardImageElement.src !== targetSrc) {
                cardImageElement.src = targetSrc;
            }
            photoOverlay.classList.add('active');
        } else {
            photoOverlay.classList.remove('active');
        }

        renderer.render(scene, camera);
    }
    
    // ç«‹å³å¯åŠ¨åŠ¨ç”»
    animate();

    // ==========================================
    // 4. æœ€ååŠ è½½ MediaPipe (é˜²æ­¢é˜»å¡)
    // ==========================================
    const videoElement = document.getElementsByClassName('input_video')[0];
    
    try {
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.isHandDetected = true;
                const lm = results.multiHandLandmarks[0];
                const p5 = lm[5]; const p17 = lm[17];
                state.handRotation = Math.atan2(p17.y - p5.y, p17.x - p5.x); 
                
                const wrist = lm[0]; const middleMCP = lm[9]; 
                const palmSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                const tipsAvg = (Math.hypot(lm[8].x-wrist.x, lm[8].y-wrist.y) + Math.hypot(lm[12].x-wrist.x, lm[12].y-wrist.y))/2;
                let open = (tipsAvg / palmSize - 1.0) / 1.0;
                state.targetFactor = Math.max(0, Math.min(1, open));

                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                if (state.scatterFactor > 0.8 && pinchDist < 0.15 * (palmSize * 8)) state.isPinch = true;
                else state.isPinch = false;
            } else {
                state.isHandDetected = false; state.isPinch = false; state.targetFactor = 0;
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start().then(() => {
            statusBar.innerText = "Camera Ready - Show Hand";
        });
    } catch(e) {
        console.error(e);
        statusBar.innerText = "System Error (Check Console)";
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
