<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Duplex Ventures Christmas (Auto-Unlock)</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Lato', sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; align-items: center; padding-top: 5vh;
        }
        
        h1 {
            color: #fff; font-family: 'Cinzel', serif; 
            font-size: 26px; line-height: 1.4; letter-spacing: 2px; text-align: center;
            margin: 0; 
            text-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 0 40px rgba(0, 200, 255, 0.5); 
            opacity: 1;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(255, 215, 0, 0.6); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 10px #fff; }
        }

        #status-bar {
            margin-top: 15px;
            color: #00ffcc; font-size: 16px; font-weight: bold;
            background: rgba(0, 0, 0, 0.7); padding: 8px 20px; border-radius: 20px;
            border: 1px solid rgba(0, 255, 204, 0.5); opacity: 0; transition: opacity 0.3s;
            text-transform: uppercase; letter-spacing: 1px;
            text-shadow: 0 0 10px #00ffcc;
        }

        /* ğŸ”‡ é™éŸ³æç¤ºå›¾æ ‡ (åªæœ‰è‡ªåŠ¨æ’­æ”¾å¤±è´¥æ—¶æ‰å‡ºç°) */
        #mute-indicator {
            position: fixed; top: 20px; right: 20px; z-index: 999;
            font-size: 24px; color: #d4af37; opacity: 0; transition: opacity 0.5s;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 50%;
            pointer-events: none;
        }
        
        #loading {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-family: 'Cinzel', serif; z-index: 20; font-size: 12px;
            text-align: center; width: 100%; text-shadow: 0 0 5px #000;
        }

        .instruction {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.9); font-size: 12px; letter-spacing: 0.5px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding-bottom: 25px; line-height: 1.8; text-shadow: 0 0 2px black;
        }
        .instruction b { color: #ffd700; }

        #photo-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            width: 300px; height: 400px;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.8); border-radius: 15px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.4);
            display: flex; justify-content: center; align-items: center;
            opacity: 0; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 100; pointer-events: none;
        }
        #photo-overlay.active { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        #photo-overlay img { width: 95%; height: 95%; object-fit: contain; border-radius: 10px; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <audio id="bgm" loop preload="auto">
    <source src="./music.mp3" type="audio/mpeg">
</audio>

<audio id="sfx-chime" preload="auto">
    <source src="https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg" type="audio/ogg">
</audio>

<audio id="sfx-boom" preload="auto">
    <source src="https://actions.google.com/sounds/v1/fireworks/fireworks_whistle_and_explosion.ogg" type="audio/ogg">
</audio>

    <div id="mute-indicator">ğŸ”‡</div>
    <div id="loading">âœ¨ Initializing...<br><span style="font-size:10px; opacity:0.7">Please allow camera</span></div>

    <div id="ui-layer">
        <h1>Duplex Ventures<br>Wish You A<br>Merry Christmas</h1>
        <div id="status-bar">Detecting...</div>
        <div id="photo-overlay"><img id="card-image" src="" alt="Card"></div>
        <div class="instruction">
            ğŸ– <b>Open</b>: Fireworks &nbsp;|&nbsp; âœŒï¸ <b>Peace</b>: Snow<br>
            ğŸ‘ <b>Thumb</b>: Rainbow &nbsp;|&nbsp; â˜ï¸ <b>Index</b>: Magic Trail<br>
            ğŸ‘‹ <b>Wave</b>: Rotate &nbsp;|&nbsp; ğŸ‘Œ <b>Pinch</b>: Card
        </div>
    </div>

    <video class="input_video" playsinline webkit-playsinline muted autoplay></video>
    <div id="canvas-container"></div>

<script>
    // ==========================================
    // 0. æ™ºèƒ½éŸ³é¢‘è§£é”é€»è¾‘ (Smart Unlock)
    // ==========================================
    const bgm = document.getElementById('bgm');
    const sfxChime = document.getElementById('sfx-chime');
    const sfxBoom = document.getElementById('sfx-boom');
    const muteIndicator = document.getElementById('mute-indicator');
    
    bgm.volume = 0.4;

    function playAudio() {
        bgm.play().then(() => {
            // æ’­æ”¾æˆåŠŸï¼Œéšè—é™éŸ³å›¾æ ‡
            muteIndicator.style.opacity = 0;
            // ç§»é™¤ç›‘å¬ï¼ŒèŠ‚çœæ€§èƒ½
            document.removeEventListener('click', playAudio);
            document.removeEventListener('touchstart', playAudio);
        }).catch(error => {
            // æ’­æ”¾å¤±è´¥ï¼ˆè¢«æµè§ˆå™¨æ‹¦æˆªï¼‰ï¼Œæ˜¾ç¤ºé™éŸ³å›¾æ ‡æç¤ºç”¨æˆ·
            console.log("Autoplay blocked, waiting for touch.");
            muteIndicator.style.opacity = 1;
        });
    }

    // 1. é¡µé¢åŠ è½½æ—¶ç«‹å³å°è¯•æ’­æ”¾
    window.addEventListener('load', playAudio);

    // 2. åªè¦ç”¨æˆ·ç¢°åˆ°å±å¹•ä»»ä½•åœ°æ–¹ï¼ˆå“ªæ€•ä¸æ˜¯ç‚¹æŒ‰é’®ï¼‰ï¼Œç«‹å³è§£é”éŸ³é¢‘
    document.addEventListener('click', playAudio);
    document.addEventListener('touchstart', playAudio);
    
    // 3. å¾®ä¿¡å…¼å®¹
    document.addEventListener("WeixinJSBridgeReady", function () {
        bgm.play();
        muteIndicator.style.opacity = 0;
    }, false);


    // --------------------------------------------------------
    // GENERATE CARD IMAGE
    // --------------------------------------------------------
    function generateChristmasCard() {
        const cvs = document.createElement('canvas'); cvs.width = 600; cvs.height = 800;
        const ctx = cvs.getContext('2d');
        const grad = ctx.createLinearGradient(0,0,0,800); grad.addColorStop(0, '#8B0000'); grad.addColorStop(1, '#300000');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, 600, 800);
        ctx.strokeStyle = '#D4AF37'; ctx.lineWidth = 15; ctx.strokeRect(20, 20, 560, 760); ctx.lineWidth = 2; ctx.strokeRect(35, 35, 530, 730);
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 10;
        ctx.fillStyle = '#D4AF37'; ctx.font = 'bold 55px serif'; ctx.fillText('Duplex Ventures', 300, 260);
        ctx.fillStyle = '#FFF'; ctx.font = 'italic 40px serif'; ctx.fillText('Wish You A', 300, 340);
        ctx.fillStyle = '#D4AF37'; ctx.font = 'bold 65px serif'; ctx.fillText('Merry Christmas', 300, 440);
        ctx.fillStyle = '#FFF'; ctx.font = '40px serif'; ctx.fillText('â˜…', 300, 160); ctx.fillText('â˜…', 300, 560);
        return cvs.toDataURL();
    }
    document.getElementById('card-image').src = generateChristmasCard();

    // ==========================================
    // 1. THREE.JS SETUP
    // ==========================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.0005);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(0, 150, 450); camera.lookAt(0, 120, 0);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // TEXTURE
    function createSuperGlowTexture() {
        const size = 64; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d'); const c = size / 2;
        const g = ctx.createRadialGradient(c, c, 0, c, c, c);
        g.addColorStop(0, 'rgba(255, 255, 255, 1)');
        g.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
        g.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(c, c, c, 0, 2 * Math.PI); ctx.fill();
        return new THREE.Texture(canvas);
    }
    const particleTexture = createSuperGlowTexture();
    particleTexture.needsUpdate = true;

    // --- TREE PARTICLES ---
    const treeGroup = new THREE.Group(); treeGroup.position.y = 120; scene.add(treeGroup);
    
    const isMobile = window.innerWidth < 768;
    const particleCount = isMobile ? 6500 : 13000; 
    const treeHeight = 280; const baseRadius = 110;
    
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const initialPositions = new Float32Array(particleCount * 3);
    const scatterDirs = new Float32Array(particleCount * 3);
    const originalColors = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const blinkOffsets = new Float32Array(particleCount);
    const blinkSpeeds = new Float32Array(particleCount);

    const colGreen = new THREE.Color(0x00ff44);
    const colRed = new THREE.Color(0xff0000);
    const colGold = new THREE.Color(0xffd700);
    const colWhite = new THREE.Color(0xffffff);

    for (let i = 0; i < particleCount; i++) {
        const hRatio = Math.pow(Math.random(), 0.8);
        const y = (hRatio - 0.5) * treeHeight;
        let r = baseRadius * (1 - hRatio) + (Math.random() - 0.5) * 20; r = Math.max(0, r);
        const theta = Math.random() * Math.PI * 2;
        const x = r * Math.cos(theta); const z = r * Math.sin(theta);

        initialPositions[i*3]=x; initialPositions[i*3+1]=y; initialPositions[i*3+2]=z;
        positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;

        const centerX=0; const centerY=50; const centerZ=0;
        let dirX=x-centerX; let dirY=y-centerY; let dirZ=z-centerZ;
        const len = Math.sqrt(dirX*dirX+dirY*dirY+dirZ*dirZ);
        dirX/=len; dirY/=len; dirZ/=len;
        const speed = 100 + Math.random() * 250; 
        scatterDirs[i*3]=dirX*speed; scatterDirs[i*3+1]=dirY*speed; scatterDirs[i*3+2]=dirZ*speed;

        let c; const rand = Math.random();
        if (rand < 0.60) c = colGreen; else if (rand < 0.80) c = colRed; else if (rand < 0.95) c = colGold; else c = colWhite;
        
        originalColors[i*3]=c.r; originalColors[i*3+1]=c.g; originalColors[i*3+2]=c.b;
        colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;

        blinkOffsets[i] = Math.random() * Math.PI * 2;
        blinkSpeeds[i] = 1.0 + Math.random() * 3.0; 
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const material = new THREE.PointsMaterial({
        size: isMobile ? 5.5 : 4.5, vertexColors: true, map: particleTexture,
        blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.9
    });

    const particles = new THREE.Points(geometry, material);
    treeGroup.add(particles);

    // ==========================================
    // ORNAMENTS
    // ==========================================
    const ornamentGroup = new THREE.Group();
    treeGroup.add(ornamentGroup); 

    function createOrnamentTexture(colorHex) {
        const size = 128; const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
        const ctx = cvs.getContext('2d'); const c = size / 2;
        const g = ctx.createRadialGradient(c - 20, c - 20, 5, c, c, 60);
        g.addColorStop(0, '#ffffff'); g.addColorStop(0.3, colorHex); g.addColorStop(1, '#000000'); 
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(c, c, 60, 0, Math.PI * 2); ctx.fill();
        return new THREE.Texture(cvs);
    }
    const texRed = createOrnamentTexture('#ff0033');
    const texGold = createOrnamentTexture('#ffd700');
    const texBlue = createOrnamentTexture('#0088ff');
    texRed.needsUpdate = true; texGold.needsUpdate = true; texBlue.needsUpdate = true;
    
    const ornamentData = [];
    const ornamentCount = 55;

    for (let i = 0; i < ornamentCount; i++) {
        const mat = new THREE.SpriteMaterial({ map: i % 3 === 0 ? texRed : (i % 3 === 1 ? texGold : texBlue), transparent: true, opacity: 1 });
        const sprite = new THREE.Sprite(mat);
        const hRatio = Math.random() * 0.85 + 0.05; 
        const y = (hRatio - 0.5) * treeHeight;
        const r = baseRadius * (1 - hRatio) + 12; 
        const theta = Math.random() * Math.PI * 2;
        const x = r * Math.cos(theta); const z = r * Math.sin(theta);
        sprite.position.set(x, y, z);
        const randomScale = 4 + Math.random() * 4; 
        sprite.scale.set(randomScale, randomScale, 1); 
        ornamentGroup.add(sprite);

        const dirX = x; const dirY = y - 50; const dirZ = z;
        const len = Math.sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ);
        ornamentData.push({
            sprite: sprite, ox: x, oy: y, oz: z, 
            dx: (dirX/len) * 350, dy: (dirY/len) * 350, dz: (dirZ/len) * 350
        });
    }

    // TOP STAR
    const topStar = new THREE.Mesh(new THREE.OctahedronGeometry(12, 0), new THREE.MeshBasicMaterial({ color: 0xffd700, wireframe: true }));
    const starOrigin = { x: 0, y: treeHeight/2 + 8, z: 0 };
    topStar.position.set(starOrigin.x, starOrigin.y, starOrigin.z);
    treeGroup.add(topStar);
    const starGlow = new THREE.Sprite(new THREE.SpriteMaterial({ map: particleTexture, color: 0xffd700, blending: THREE.AdditiveBlending, opacity: 1.0 }));
    starGlow.scale.set(100, 100, 1); topStar.add(starGlow);

    // MAGIC TRAIL
    const trailCount = 60;
    const trailGeo = new THREE.BufferGeometry();
    const trailPos = new Float32Array(trailCount * 3);
    const trailColors = new Float32Array(trailCount * 3); 
    for(let i=0; i<trailCount; i++) { trailPos[i*3]=0; trailPos[i*3+1]=0; trailPos[i*3+2]=0; trailColors[i*3]=0; trailColors[i*3+1]=0; trailColors[i*3+2]=0; }
    trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
    trailGeo.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
    const trailMat = new THREE.PointsMaterial({ size: 12, vertexColors: true, map: particleTexture, transparent: true, opacity: 1, blending: THREE.AdditiveBlending, depthWrite: false });
    const trailSystem = new THREE.Points(trailGeo, trailMat);
    scene.add(trailSystem);
    let trailHead = 0;

    // SNOW SYSTEM
    const snowCount = 1000;
    const snowGeo = new THREE.BufferGeometry();
    const snowPos = new Float32Array(snowCount * 3);
    const snowVel = new Float32Array(snowCount); 
    for(let i=0; i<snowCount; i++) {
        snowPos[i*3] = (Math.random() - 0.5) * 800; snowPos[i*3+1] = Math.random() * 600 + 200; snowPos[i*3+2] = (Math.random() - 0.5) * 600; 
        snowVel[i] = 1 + Math.random() * 3; 
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    const snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 6, map: particleTexture, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false }));
    scene.add(snowSystem); snowSystem.visible = false; 

    // ==========================================
    // HAND TRACKING
    // ==========================================
    let state = { 
        isHandDetected: false, handRotation: 0, isPinch: false, scatterFactor: 0, targetFactor: 0,
        isPeaceSign: false, isThumbsUp: false,
        handX: 0, handY: 0, handZ: 0 
    };
    
    let hasPlayedBoom = false;
    let hasPlayedChime = false;

    const photoOverlay = document.getElementById('photo-overlay');
    const videoElement = document.getElementsByClassName('input_video')[0];
    const statusBar = document.getElementById('status-bar');
    
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    
    hands.onResults(results => {
        document.getElementById('loading').style.display = 'none';
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            state.isHandDetected = true;
            const lm = results.multiHandLandmarks[0];
            const p5 = lm[5]; const p17 = lm[17];
            state.handRotation = Math.atan2(p17.y - p5.y, p17.x - p5.x);
            
            const wrist = lm[0]; const middleMCP = lm[9]; const palmSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
            const tipsAvg = (Math.hypot(lm[8].x-wrist.x, lm[8].y-wrist.y) + Math.hypot(lm[12].x-wrist.x, lm[12].y-wrist.y) + Math.hypot(lm[16].x-wrist.x, lm[16].y-wrist.y)) / 3;
            state.targetFactor = Math.max(0, Math.min(1, (tipsAvg / palmSize - 1.2) / 1.0));
            
            const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            state.isPinch = (pinchDist < 0.05 * (palmSize * 10) && state.targetFactor > 0.3);

            const screenX = (0.5 - lm[8].x) * 800; 
            const screenY = (0.5 - lm[8].y) * 600; 
            state.handX = screenX; state.handY = screenY; state.handZ = 150; 

            const iTip = Math.hypot(lm[8].x - wrist.x, lm[8].y - wrist.y);
            const mTip = Math.hypot(lm[12].x - wrist.x, lm[12].y - wrist.y);
            const rTip = Math.hypot(lm[16].x - wrist.x, lm[16].y - wrist.y);
            const pTip = Math.hypot(lm[20].x - wrist.x, lm[20].y - wrist.y);

            state.isPeaceSign = (iTip > palmSize * 1.5 && mTip > palmSize * 1.5 && rTip < palmSize * 1.5 && pTip < palmSize * 1.5);
            
            const tTipDist = Math.hypot(lm[4].x - lm[9].x, lm[4].y - lm[9].y); 
            state.isThumbsUp = (tTipDist > palmSize && iTip < palmSize * 1.5 && mTip < palmSize * 1.5);

        } else {
            state.isHandDetected = false; state.isPinch = false; state.targetFactor = 0;
            state.isPeaceSign = false; state.isThumbsUp = false;
        }
    });

    // æ€§èƒ½ä¼˜åŒ–: 3å¸§ä¸€æ¬¡
    let frameCounter = 0;
    const cameraUtils = new Camera(videoElement, { 
        onFrame: async () => { 
            frameCounter++;
            if (frameCounter % 3 === 0) {
                await hands.send({image: videoElement}); 
            }
        }, 
        width: 640, height: 480 
    });
    cameraUtils.start();

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.003; 

        // å¿«é€Ÿå…³é—­é€»è¾‘
        const animSpeed = (state.targetFactor < state.scatterFactor) ? 0.1 : 0.03;
        state.scatterFactor += (state.targetFactor - state.scatterFactor) * animSpeed;

        const t = state.scatterFactor;
        const explosionProgress = 1 - Math.pow(1 - t, 3);
        const gravityDrop = 200 * t * t;

        // éŸ³æ•ˆè§¦å‘
        if (t > 0.6 && !hasPlayedBoom) { sfxBoom.currentTime=0; sfxBoom.play().catch(()=>{}); hasPlayedBoom = true; }
        if (t < 0.2) { hasPlayedBoom = false; }
        if (state.isPinch && !hasPlayedChime) { sfxChime.currentTime=0; sfxChime.play().catch(()=>{}); hasPlayedChime = true; }
        if (!state.isPinch) { hasPlayedChime = false; }

        const posAttr = geometry.attributes.position;
        const colAttr = geometry.attributes.color;
        
        if (state.isHandDetected) {
            statusBar.style.opacity = 1;
            if (state.isPinch) statusBar.innerText = "OPENING CARD";
            else if (state.isPeaceSign) statusBar.innerText = "â„ï¸ SNOW MODE â„ï¸";
            else if (state.isThumbsUp) statusBar.innerText = "ğŸŒˆ RAINBOW MODE ğŸŒˆ";
            else if (t > 0.5) statusBar.innerText = "ğŸ’¥ FIREWORKS";
            else statusBar.innerText = "READY";
        } else {
            statusBar.style.opacity = 0;
        }

        // Trail Update
        const trailC = trailGeo.attributes.color.array;
        for(let i=0; i<trailCount; i++) {
            trailC[i*3] *= 0.85; trailC[i*3+1] *= 0.85; trailC[i*3+2] *= 0.85;
        }
        if (state.isHandDetected) {
            const tp = trailGeo.attributes.position.array;
            tp[trailHead * 3] = state.handX;
            tp[trailHead * 3 + 1] = state.handY;
            tp[trailHead * 3 + 2] = state.handZ; 
            trailC[trailHead * 3] = 1.0; trailC[trailHead * 3 + 1] = 0.8; trailC[trailHead * 3 + 2] = 0.2; 
            trailHead = (trailHead + 1) % trailCount;
        }
        trailGeo.attributes.position.needsUpdate = true;
        trailGeo.attributes.color.needsUpdate = true;

        // Tree Particles Logic
        for (let i = 0; i < particleCount; i++) {
            const ix = i * 3; const iy = i * 3 + 1; const iz = i * 3 + 2;
            let ox = initialPositions[ix]; let oy = initialPositions[iy]; let oz = initialPositions[iz];
            
            let tx = ox + scatterDirs[ix] * explosionProgress;
            let ty = oy + scatterDirs[iy] * explosionProgress - gravityDrop;
            let tz = oz + scatterDirs[iz] * explosionProgress;

            if (state.isHandDetected && state.scatterFactor < 0.2) {
                const dx = tx - state.handX; const dy = ty - state.handY; const dz = tz - state.handZ;
                const distSq = dx*dx + dy*dy + dz*dz;
                if (distSq < 8000) { 
                    const force = (8000 - distSq) / 8000;
                    tx += dx * force * 0.8; ty += dy * force * 0.8; tz += dz * force * 0.8;
                }
            }
            posAttr.array[ix] = tx; posAttr.array[iy] = ty; posAttr.array[iz] = tz;

            let baseBlink = 0.5 + 0.5 * Math.sin(time * blinkSpeeds[i] + blinkOffsets[i]);
            if (i % 20 === 0 && Math.sin(time * 5 + i) > 0.95) baseBlink = 2.5; 
            if (t > 0.1) baseBlink *= 1.5; 

            if (state.isThumbsUp) {
                const hue = (time * 0.2 + i * 0.0001) % 1; 
                const color = new THREE.Color().setHSL(hue, 1.0, 0.5);
                colAttr.array[ix] = color.r * 1.5; colAttr.array[iy] = color.g * 1.5; colAttr.array[iz] = color.b * 1.5;
            } else {
                colAttr.array[ix] = originalColors[ix] * baseBlink; colAttr.array[iy] = originalColors[iy] * baseBlink; colAttr.array[iz] = originalColors[iz] * baseBlink;
            }
        }
        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true; 

        // Ornaments Logic
        for (let i = 0; i < ornamentCount; i++) {
            const data = ornamentData[i];
            const sprite = data.sprite;
            let tx = data.ox + data.dx * explosionProgress;
            let ty = data.oy + data.dy * explosionProgress - gravityDrop;
            let tz = data.oz + data.dz * explosionProgress;

            if (state.isHandDetected && state.scatterFactor < 0.2) {
                const dx = tx - state.handX; const dy = ty - state.handY; const dz = tz - state.handZ;
                const distSq = dx*dx + dy*dy + dz*dz;
                if (distSq < 8000) { 
                    const force = (8000 - distSq) / 8000;
                    tx += dx * force * 0.8; ty += dy * force * 0.8; tz += dz * force * 0.8;
                }
            }
            sprite.position.set(tx, ty, tz);
            sprite.material.opacity = 1 - explosionProgress;
        }

        if (state.isPeaceSign) {
            snowSystem.visible = true;
            const snowPositions = snowGeo.attributes.position.array;
            for(let i=0; i<snowCount; i++) {
                snowPositions[i*3+1] -= snowVel[i];
                snowPositions[i*3] += Math.sin(time + i) * 0.5;
                if (snowPositions[i*3+1] < -200) snowPositions[i*3+1] = 600;
            }
            snowGeo.attributes.position.needsUpdate = true;
        } else {
            snowSystem.visible = false;
        }

        topStar.position.y = starOrigin.y - gravityDrop;
        topStar.material.opacity = 1 - state.scatterFactor;
        starGlow.material.opacity = 1.0 * (1 - state.scatterFactor);
        topStar.rotation.y += 0.05;

        if (state.scatterFactor < 0.8) {
            if (state.isHandDetected) {
                treeGroup.rotation.y += (-state.handRotation * 1.5 - treeGroup.rotation.y) * 0.05;
            } else {
                treeGroup.rotation.y += 0.003;
            }
        }

        if (state.isPinch && state.isHandDetected) photoOverlay.classList.add('active');
        else photoOverlay.classList.remove('active');

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
