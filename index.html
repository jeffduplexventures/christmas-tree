<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duplex Ventures Christmas Magic</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Lato', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; align-items: center; padding-top: 5vh;
        }
        
        h1 {
            color: #fff; font-family: 'Cinzel', serif; 
            font-size: 26px; line-height: 1.4; letter-spacing: 2px; text-align: center;
            margin: 0; text-shadow: 0 0 15px rgba(255, 215, 0, 0.8); opacity: 1;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 25px rgba(255, 215, 0, 1); }
        }

        .input_video { display: none; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-family: 'Cinzel', serif; z-index: 20;
            text-align: center; width: 100%; font-size: 18px;
        }

        #card-indicator {
            margin-top: 10px; color: #ffd700; font-family: 'Cinzel', serif; font-size: 18px;
            background: rgba(0,0,0,0.6); padding: 5px 15px; border-radius: 20px;
            border: 1px solid rgba(255, 215, 0, 0.3); opacity: 0.8; transition: opacity 0.3s;
        }

        .instruction {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.6); font-size: 14px; letter-spacing: 1px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding-bottom: 25px; line-height: 1.8;
        }
        .instruction b { color: #ffd700; }

        #photo-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            width: 300px; height: 400px;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px);
            border: 2px solid rgba(212, 175, 55, 0.6); border-radius: 15px;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 100; box-shadow: 0 0 40px rgba(0,0,0,0.8); pointer-events: none;
        }
        #photo-overlay.active { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        #photo-overlay img { width: 95%; height: 95%; object-fit: cover; border-radius: 10px; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">âœ¨ Preparing Christmas Magic...<br><span style="font-size:12px; opacity:0.7">Please allow camera access & wait for loading</span></div>

    <div id="ui-layer">
        <h1>Duplex Ventures<br>Wish You A<br>Merry Christmas</h1>
        <div id="card-indicator">Detecting Hand...</div>
        <div id="photo-overlay"><img id="card-image" src="" alt="Christmas Photo"></div>
        <div class="instruction">
            ğŸ– <b>Open</b>: Scatter Tree & Reveal Photos<br>
            ğŸ‘‹ <b>Tilt Hand</b>: Select Photo | ğŸ‘Œ <b>Pinch</b>: View Full Size
        </div>
    </div>

    <video class="input_video"></video>
    <div id="canvas-container"></div>

<script>
    // ==========================================
    // 0. å‡†å¤‡ç…§ç‰‡ç´ æ & åŠ è½½ç®¡ç†å™¨
    // ==========================================
    
    // ä¿®æ”¹ï¼šè¿”å› Canvas å¯¹è±¡è€Œä¸æ˜¯ DataURLï¼Œæ–¹ä¾¿ THREE.js ä½¿ç”¨
    function generateOriginalCardCanvas() {
        const cvs = document.createElement('canvas');
        cvs.width = 600; cvs.height = 800;
        const ctx = cvs.getContext('2d');
        const grad = ctx.createLinearGradient(0,0,0,800);
        grad.addColorStop(0, '#8B0000'); grad.addColorStop(1, '#300000');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, 600, 800);
        ctx.strokeStyle = '#D4AF37'; ctx.lineWidth = 15; ctx.strokeRect(20, 20, 560, 760);
        ctx.lineWidth = 2; ctx.strokeRect(35, 35, 530, 730);
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 10;
        ctx.fillStyle = '#D4AF37'; ctx.font = 'bold 55px serif'; ctx.fillText('Duplex Ventures', 300, 260);
        ctx.fillStyle = '#FFF'; ctx.font = 'italic 40px serif'; ctx.fillText('Wish You A', 300, 340);
        ctx.fillStyle = '#D4AF37'; ctx.font = 'bold 65px serif'; ctx.fillText('Merry Christmas', 300, 440);
        ctx.fillStyle = '#FFF'; ctx.font = '40px serif'; ctx.fillText('â˜…', 300, 160); ctx.fillText('â˜…', 300, 560);
        return cvs;
    }

    // 5å¼ ç²¾é€‰åœ£è¯ç…§ç‰‡çš„ URL (ç¬¬ä¸€å¼ æ˜¯å ä½ç¬¦)
    const photoUrls = [
        null, // å°†ç”± Canvas ç”Ÿæˆ
        'https://images.unsplash.com/photo-1543589077-47d81606c1bf?w=400&q=80', // åœ£è¯æ ‘
        'https://images.unsplash.com/photo-1512909006721-3d6018887383?w=400&q=80', // ç¤¼ç‰©
        'https://images.unsplash.com/photo-1545048702-79362596cdc9?w=400&q=80', // è£…é¥°å“
        'https://images.unsplash.com/photo-1576919228236-a097c32a5cd4?w=400&q=80'  // å½©ç¯
    ];

    const photoGallerySrcs = []; // ç”¨äº HTML å¼¹çª—çš„æºåœ°å€
    const photoTextures = [];    // ç”¨äº 3D åœºæ™¯çš„çº¹ç†
    const loadingManager = new THREE.LoadingManager();
    const textureLoader = new THREE.TextureLoader(loadingManager);

    // 1. å¤„ç†ç¬¬ä¸€å¼  Canvas ç…§ç‰‡
    const cardCanvas = generateOriginalCardCanvas();
    photoGallerySrcs[0] = cardCanvas.toDataURL();
    photoTextures[0] = new THREE.CanvasTexture(cardCanvas);

    // 2. åŠ è½½å…¶ä½™ç½‘ç»œç…§ç‰‡
    for (let i = 1; i < 5; i++) {
        photoGallerySrcs[i] = photoUrls[i];
        textureLoader.load(photoUrls[i], (texture) => {
            photoTextures[i] = texture;
        });
    }

    loadingManager.onLoad = () => {
        document.getElementById('loading').style.display = 'none';
        createFloatingPhotos(); // æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæ¯•åï¼Œåˆ›å»º 3D ç…§ç‰‡å¢™
    };

    const cardImageElement = document.getElementById('card-image');
    const indicatorElement = document.getElementById('card-indicator');
    let currentPhotoIndex = 0;

    // ==========================================
    // 1. THREE.JS åœºæ™¯ä¸ç²’å­æ ‘
    // ==========================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020202); 
    scene.fog = new THREE.FogExp2(0x020202, 0.001);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(0, 150, 450); camera.lookAt(0, 120, 0);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    function createGlowTexture() { /* ... (ä¿æŒä¸å˜) ... */
        const size = 64; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d'); const c = size / 2;
        const g = ctx.createRadialGradient(c, c, 0, c, c, c);
        g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(0.2, 'rgba(255,255,255,0.8)'); g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(c, c, c, 0, 2 * Math.PI); ctx.fill(); return new THREE.Texture(canvas);
    }
    const particleTexture = createGlowTexture(); particleTexture.needsUpdate = true;
    const treeGroup = new THREE.Group(); treeGroup.position.y = 120; scene.add(treeGroup);
    const isMobile = window.innerWidth < 768; const particleCount = isMobile ? 6000 : 12000; 
    const treeHeight = 280; const baseRadius = 110;
    const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(particleCount * 3); const initialPositions = new Float32Array(particleCount * 3); const scatterDirs = new Float32Array(particleCount * 3); const originalColors = new Float32Array(particleCount * 3); const colors = new Float32Array(particleCount * 3); const blinkOffsets = new Float32Array(particleCount); const blinkSpeeds = new Float32Array(particleCount);
    const colGold = new THREE.Color(0xffcc00); const colWhite = new THREE.Color(0xffffee); const colRed = new THREE.Color(0xff0033);
    for (let i = 0; i < particleCount; i++) { /* ... (ä¿æŒä¸å˜ï¼Œç”Ÿæˆç²’å­æ•°æ®) ... */
        const hRatio = Math.pow(Math.random(), 0.8); const y = (hRatio - 0.5) * treeHeight;
        let r = baseRadius * (1 - hRatio) + (Math.random() - 0.5) * 20; r = Math.max(0, r);
        const theta = Math.random() * Math.PI * 2; const x = r * Math.cos(theta); const z = r * Math.sin(theta);
        initialPositions[i*3] = x; initialPositions[i*3+1] = y; initialPositions[i*3+2] = z;
        positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
        const centerX = 0; const centerY = 50; const centerZ = 0;
        let dirX = x - centerX; let dirY = y - centerY; let dirZ = z - centerZ; const len = Math.sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ); dirX /= len; dirY /= len; dirZ /= len;
        const speed = 100 + Math.random() * 250; scatterDirs[i*3] = dirX * speed; scatterDirs[i*3+1] = dirY * speed; scatterDirs[i*3+2] = dirZ * speed;
        let c; const rand = Math.random(); if (rand > 0.85) c = colRed; else if (rand > 0.50) c = colWhite; else c = Math.random() > 0.5 ? colGold : new THREE.Color(0xffaa00);
        originalColors[i*3] = c.r; originalColors[i*3+1] = c.g; originalColors[i*3+2] = c.b; colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
        blinkOffsets[i] = Math.random() * Math.PI * 2; blinkSpeeds[i] = 0.5 + Math.random() * 2.0;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const material = new THREE.PointsMaterial({ size: isMobile ? 4.5 : 3.5, vertexColors: true, map: particleTexture, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 1 });
    const particles = new THREE.Points(geometry, material); treeGroup.add(particles);
    const starGeo = new THREE.OctahedronGeometry(10, 0); const starMat = new THREE.MeshBasicMaterial({ color: 0xffffee, wireframe: true, transparent: true });
    const topStar = new THREE.Mesh(starGeo, starMat); const starOrigin = { x: 0, y: treeHeight/2 + 8, z: 0 }; topStar.position.set(starOrigin.x, starOrigin.y, starOrigin.z); treeGroup.add(topStar);
    const glowMat = new THREE.SpriteMaterial({ map: particleTexture, color: 0xffd700, transparent: true, blending: THREE.AdditiveBlending, opacity: 0.8 }); const starGlow = new THREE.Sprite(glowMat); starGlow.scale.set(70, 70, 1); topStar.add(starGlow);

    // ==========================================
    // æ–°å¢: åˆ›å»ºæ‚¬æŒ‚çš„ 3D ç…§ç‰‡
    // ==========================================
    const hangingGroup = new THREE.Group();
    scene.add(hangingGroup);
    hangingGroup.visible = false; // åˆå§‹éšè—

    const photoPositions = [
        { x: 0, y: 180, z: -50 },    // ä¸­ä¸Š (è´ºå¡)
        { x: -90, y: 160, z: -20 },  // å·¦ä¸Š
        { x: -150, y: 120, z: 20 },  // å·¦ä¸‹
        { x: 90, y: 160, z: -20 },   // å³ä¸Š
        { x: 150, y: 120, z: 20 }    // å³ä¸‹
    ];
    const photoMeshes = [];

    function createFloatingPhotos() {
        const planeGeo = new THREE.PlaneGeometry(45, 60); // 3:4 æ¯”ä¾‹
        const frameGeo = new THREE.PlaneGeometry(50, 65); // è¾¹æ¡†
        const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

        for (let i = 0; i < 5; i++) {
            const group = new THREE.Group();
            // ç›¸æ¡†
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.z = -1; 
            group.add(frame);
            // ç…§ç‰‡
            const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide, transparent: true, opacity: 0 });
            const mesh = new THREE.Mesh(planeGeo, mat);
            group.add(mesh);
            
            group.position.set(photoPositions[i].x, photoPositions[i].y, photoPositions[i].z);
            group.lookAt(camera.position); // é¢å‘æ‘„åƒæœº
            
            hangingGroup.add(group);
            photoMeshes.push({ group, material: mat, originalY: photoPositions[i].y });
        }
    }

    // ==========================================
    // 2. é€»è¾‘æ§åˆ¶ (æ‰‹åŠ¿è¯†åˆ«)
    // ==========================================
    let state = { isHandDetected: false, handRotation: 0, isPinch: false, scatterFactor: 0, targetFactor: 0 };
    const photoOverlay = document.getElementById('photo-overlay');
    const videoElement = document.getElementsByClassName('input_video')[0];
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    
    hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            state.isHandDetected = true;
            const lm = results.multiHandLandmarks[0];
            const p5 = lm[5]; const p17 = lm[17];
            state.handRotation = Math.atan2(p17.y - p5.y, p17.x - p5.x); // è®¡ç®—æ—‹è½¬
            const wrist = lm[0]; const middleMCP = lm[9]; const palmSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
            const avgTipDist = (Math.hypot(lm[8].x-wrist.x, lm[8].y-wrist.y) + Math.hypot(lm[12].x-wrist.x, lm[12].y-wrist.y) + Math.hypot(lm[16].x-wrist.x, lm[16].y-wrist.y)) / 3;
            state.targetFactor = Math.max(0, Math.min(1, (avgTipDist / palmSize - 1.2) / (2.2 - 1.2))); // è®¡ç®—å¼ å¼€ç¨‹åº¦
            state.isPinch = (Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y) < 0.05 * (palmSize * 10) && state.targetFactor > 0.3); // è®¡ç®—æåˆ
        } else {
            state.isHandDetected = false; state.isPinch = false; state.targetFactor = 0; 
        }
    });
    const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
    cameraUtils.start();

    // ==========================================
    // 3. æ¸²æŸ“å¾ªç¯ (æ ¸å¿ƒåŠ¨ç”»é€»è¾‘)
    // ==========================================
    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.003; 
        state.scatterFactor += (state.targetFactor - state.scatterFactor) * 0.03;
        const t = state.scatterFactor;
        const explosionProgress = 1 - Math.pow(1 - t, 3);
        const gravityDrop = 200 * t * t;

        // --- æ›´æ–°ç²’å­æ ‘ ---
        const posAttr = geometry.attributes.position; const colAttr = geometry.attributes.color;
        for (let i = 0; i < particleCount; i++) {
            const ix=i*3; const iy=i*3+1; const iz=i*3+2;
            posAttr.array[ix] = initialPositions[ix] + scatterDirs[ix] * explosionProgress;
            posAttr.array[iz] = initialPositions[iz] + scatterDirs[iz] * explosionProgress;
            posAttr.array[iy] = initialPositions[iy] + scatterDirs[iy] * explosionProgress - gravityDrop;
            const blinkVal = 0.6 + 0.6 * Math.sin(time * blinkSpeeds[i] + blinkOffsets[i]);
            colAttr.array[ix] = Math.min(1, originalColors[ix] * blinkVal);
            colAttr.array[iy] = Math.min(1, originalColors[iy] * blinkVal);
            colAttr.array[iz] = Math.min(1, originalColors[iz] * blinkVal);
        }
        posAttr.needsUpdate = true; colAttr.needsUpdate = true; 
        
        // --- æ›´æ–°é¡¶éƒ¨æ˜Ÿæ˜Ÿ ---
        const starExplosionScale = 1.1;
        topStar.position.x = starOrigin.x + (Math.random()-0.5) * 300 * explosionProgress * starExplosionScale;
        topStar.position.y = starOrigin.y + (Math.random()) * 300 * explosionProgress * starExplosionScale - gravityDrop;
        topStar.position.z = starOrigin.z + (Math.random()-0.5) * 300 * explosionProgress * starExplosionScale;
        topStar.material.opacity = 1 - state.scatterFactor; starGlow.material.opacity = 0.8 * (1 - state.scatterFactor);
        topStar.rotation.y += 0.02;

        // --- æ›´æ–°æ‚¬æŒ‚ç…§ç‰‡å¢™ (æ ¸å¿ƒæ–°åŠŸèƒ½) ---
        if (explosionProgress > 0.01) {
            hangingGroup.visible = true;
            photoMeshes.forEach((obj, index) => {
                // 1. éšæ ‘æœ¨æ•£å¼€è€Œå‡ºç°
                const scale = explosionProgress;
                obj.group.scale.set(scale, scale, scale);
                obj.material.opacity = explosionProgress;
                
                // 2. é«˜äº®é€‰ä¸­çš„ç…§ç‰‡
                if (index === currentPhotoIndex && state.isHandDetected) {
                    obj.material.color.set(0xffffff); // æ­£å¸¸äº®åº¦
                    obj.group.scale.multiplyScalar(1.15); // ç¨å¾®æ”¾å¤§
                } else {
                    obj.material.color.set(0x888888); // å˜æš—
                }

                // 3. æ·»åŠ è½»å¾®æµ®åŠ¨æ•ˆæœ
                obj.group.position.y = obj.originalY + Math.sin(time * 2 + index) * 5;
            });
        } else {
            hangingGroup.visible = false;
        }

        // --- äº¤äº’é€»è¾‘ ---
        if (state.scatterFactor < 0.8) {
            if (state.isHandDetected) {
                treeGroup.rotation.y += (-state.handRotation * 1.5 - treeGroup.rotation.y) * 0.05;
                
                // è®¡ç®—ç…§ç‰‡ç´¢å¼• (çµæ•åº¦ä¼˜åŒ–ç‰ˆ)
                let clampedRot = Math.max(-1.3, Math.min(1.3, state.handRotation));
                let norm = (clampedRot + 1.3) / 2.6; 
                currentPhotoIndex = Math.max(0, Math.min(4, Math.floor(norm * 5)));
                
                indicatorElement.innerText = `Selected Photo: ${currentPhotoIndex + 1} / 5`;
                indicatorElement.style.opacity = 1;
            } else {
                treeGroup.rotation.y += 0.002;
                indicatorElement.innerText = "Detecting Hand..."; indicatorElement.style.opacity = 0.6;
            }
        }

        // æåˆæ˜¾ç¤ºå¤§å›¾
        if (state.isPinch && state.isHandDetected) {
            if (cardImageElement.src !== photoGallerySrcs[currentPhotoIndex]) {
                cardImageElement.src = photoGallerySrcs[currentPhotoIndex];
            }
            photoOverlay.classList.add('active');
        } else {
            photoOverlay.classList.remove('active');
        }

        renderer.render(scene, camera);
    }
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    animate(); // å¼€å§‹åŠ¨ç”»å¾ªç¯
</script>
</body>
</html>
